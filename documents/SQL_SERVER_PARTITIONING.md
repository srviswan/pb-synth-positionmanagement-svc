# MS SQL Server Partitioning with Position Key

## Overview

While MS SQL Server **does not support native hash partitioning** like PostgreSQL, you can achieve similar functionality using **computed columns** with hash functions and **range partitioning**. The deterministic `position_key` generated by `PositionKeyGenerator` works perfectly with this approach.

## Key Difference: PostgreSQL vs SQL Server

### PostgreSQL (Native Hash Partitioning)
```sql
CREATE TABLE event_store (
    position_key VARCHAR(64) NOT NULL,
    ...
) PARTITION BY HASH (position_key);

CREATE TABLE event_store_p0 PARTITION OF event_store 
    FOR VALUES WITH (MODULUS 16, REMAINDER 0);
```
✅ **Native support** - Simple, efficient, automatic partition pruning

### MS SQL Server (Computed Column + Range Partitioning)
```sql
-- Step 1: Add computed column with hash
ALTER TABLE event_store 
ADD partition_hash AS (ABS(HASHBYTES('SHA2_256', position_key)) % 16) PERSISTED;

-- Step 2: Create partition function
CREATE PARTITION FUNCTION pf_event_store_hash (INT)
AS RANGE LEFT FOR VALUES (0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15);

-- Step 3: Create partition scheme
CREATE PARTITION SCHEME ps_event_store_hash
AS PARTITION pf_event_store_hash
TO ([PRIMARY], [PRIMARY], [PRIMARY], [PRIMARY], 
    [PRIMARY], [PRIMARY], [PRIMARY], [PRIMARY],
    [PRIMARY], [PRIMARY], [PRIMARY], [PRIMARY],
    [PRIMARY], [PRIMARY], [PRIMARY], [PRIMARY]);

-- Step 4: Create clustered index on partition scheme
CREATE CLUSTERED INDEX IX_event_store_partition 
ON event_store (partition_hash, position_key, event_ver)
ON ps_event_store_hash (partition_hash);
```
⚠️ **Workaround required** - More complex, but achieves same result

## Implementation for Event Store

### Complete SQL Server Schema

```sql
-- 1. Create base table (without partitioning initially)
CREATE TABLE event_store (
    position_key    VARCHAR(64) NOT NULL,
    event_ver       BIGINT NOT NULL,
    event_type      VARCHAR(30) NOT NULL,
    effective_date  DATE NOT NULL,
    occurred_at     DATETIMEOFFSET NOT NULL,
    payload         NVARCHAR(MAX) NOT NULL,  -- JSON as text
    meta_lots       NVARCHAR(MAX),          -- JSON as text
    correlation_id  VARCHAR(64),
    causation_id    VARCHAR(64),
    contract_id     VARCHAR(64),
    
    -- Computed column for partitioning
    partition_hash AS (ABS(HASHBYTES('SHA2_256', position_key)) % 16) PERSISTED
);

-- 2. Create partition function (16 partitions: 0-15)
CREATE PARTITION FUNCTION pf_event_store_hash (INT)
AS RANGE LEFT FOR VALUES (0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15);

-- 3. Create partition scheme
-- Note: All partitions can use PRIMARY filegroup, or distribute across multiple filegroups
CREATE PARTITION SCHEME ps_event_store_hash
AS PARTITION pf_event_store_hash
TO ([PRIMARY], [PRIMARY], [PRIMARY], [PRIMARY], 
    [PRIMARY], [PRIMARY], [PRIMARY], [PRIMARY],
    [PRIMARY], [PRIMARY], [PRIMARY], [PRIMARY],
    [PRIMARY], [PRIMARY], [PRIMARY], [PRIMARY]);

-- 4. Create clustered index aligned with partition scheme
CREATE CLUSTERED INDEX IX_event_store_partition 
ON event_store (partition_hash, position_key, event_ver)
ON ps_event_store_hash (partition_hash);

-- 5. Create non-clustered indexes for queries
CREATE NONCLUSTERED INDEX idx_event_replay 
ON event_store (position_key, event_ver ASC);

CREATE NONCLUSTERED INDEX idx_effective_date 
ON event_store (position_key, effective_date);

-- 6. Primary key constraint (must include partition_hash)
ALTER TABLE event_store
ADD CONSTRAINT PK_event_store 
PRIMARY KEY NONCLUSTERED (position_key, event_ver);
```

## How It Works

### 1. Deterministic Position Key Generation

The `PositionKeyGenerator` creates a deterministic 64-character hex string:
```java
String positionKey = generator.generatePositionKey("ACC001", "AAPL", "USD");
// Returns: "a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0u1v2w3x4y5z6a7b8c9d0e1f2"
```

### 2. Hash Calculation in SQL Server

SQL Server computes the partition number:
```sql
partition_hash = ABS(HASHBYTES('SHA2_256', position_key)) % 16
```

**Important**: SQL Server's `HASHBYTES('SHA2_256', ...)` produces a different hash than Java's `SHA-256`, but since we're using modulo 16, the distribution will still be even.

### 3. Partition Assignment

- `position_key = "a1b2c3d4..."` → `HASHBYTES(...)` → `12345` → `12345 % 16 = 9` → **Partition 9**
- Same `position_key` always maps to same partition (deterministic)

## Alignment with PositionKeyGenerator

### Option 1: Use SQL Server's Hash Function (Recommended)

Let SQL Server compute the partition hash:
```sql
partition_hash AS (ABS(HASHBYTES('SHA2_256', position_key)) % 16) PERSISTED
```

**Pros:**
- No application code changes needed
- SQL Server handles hash calculation
- Automatic partition assignment

**Cons:**
- Different hash algorithm than Java (but modulo ensures even distribution)
- Cannot predict partition number in application code

### Option 2: Pre-compute Partition Number in Application

Modify `PositionKeyGenerator` to use SQL Server-compatible hash:

```java
public int getPartitionNumberForSQLServer(String positionKey, int partitionCount) {
    try {
        // Use same hash algorithm as SQL Server HASHBYTES('SHA2_256', ...)
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        byte[] hashBytes = digest.digest(positionKey.getBytes(StandardCharsets.UTF_8));
        
        // Convert first 4 bytes to integer (SQL Server HASHBYTES returns VARBINARY)
        int hashValue = ((hashBytes[0] & 0xFF) << 24) |
                        ((hashBytes[1] & 0xFF) << 16) |
                        ((hashBytes[2] & 0xFF) << 8) |
                        (hashBytes[3] & 0xFF);
        
        return Math.abs(hashValue) % partitionCount;
    } catch (NoSuchAlgorithmException e) {
        throw new RuntimeException("Hash algorithm not available", e);
    }
}
```

**Note**: This may not produce identical results to SQL Server's `HASHBYTES` due to implementation differences. It's better to let SQL Server compute it.

## Performance Considerations

### Write Performance

**PostgreSQL:**
- Native hash partitioning: ~0.1ms overhead per insert
- Automatic partition pruning

**SQL Server:**
- Computed column: ~0.2-0.5ms overhead per insert (hash calculation)
- Still very fast for 2M trades/day
- Partition elimination works, but query optimizer needs proper WHERE clauses

### Query Performance

**PostgreSQL:**
```sql
SELECT * FROM event_store 
WHERE position_key = 'a1b2c3d4...'
ORDER BY event_ver;
```
✅ Automatically prunes to single partition

**SQL Server:**
```sql
SELECT * FROM event_store 
WHERE position_key = 'a1b2c3d4...'
ORDER BY event_ver;
```
✅ Also prunes to single partition (if `partition_hash` is included in WHERE or computed automatically)

### Index Strategy

**Important**: In SQL Server, the clustered index must include `partition_hash` as the first column for proper partition alignment:

```sql
CREATE CLUSTERED INDEX IX_event_store_partition 
ON event_store (partition_hash, position_key, event_ver)
ON ps_event_store_hash (partition_hash);
```

This ensures:
- Data is physically organized by partition
- Queries can efficiently eliminate partitions
- Inserts go to correct partition automatically

## Migration from PostgreSQL to SQL Server

### Schema Migration Steps

1. **Create computed column**:
   ```sql
   ALTER TABLE event_store 
   ADD partition_hash AS (ABS(HASHBYTES('SHA2_256', position_key)) % 16) PERSISTED;
   ```

2. **Create partition function and scheme**:
   ```sql
   CREATE PARTITION FUNCTION pf_event_store_hash (INT) ...
   CREATE PARTITION SCHEME ps_event_store_hash ...
   ```

3. **Rebuild table with partition alignment**:
   ```sql
   CREATE CLUSTERED INDEX IX_event_store_partition 
   ON event_store (partition_hash, position_key, event_ver)
   ON ps_event_store_hash (partition_hash);
   ```

4. **Update JSON columns**:
   - `JSONB` → `NVARCHAR(MAX)`
   - Add `ISJSON()` constraints if needed
   - Update query syntax (`->` → `JSON_VALUE()`)

### Code Changes Required

1. **JPA Entity Mapping**:
   ```java
   @Entity
   @Table(name = "event_store")
   public class EventEntity {
       @Column(name = "position_key")
       private String positionKey;
       
       @Column(name = "partition_hash", insertable = false, updatable = false)
       private Integer partitionHash; // Computed column
       
       // JSON fields as String instead of JsonNode
       @Column(name = "payload", columnDefinition = "NVARCHAR(MAX)")
       private String payload;
   }
   ```

2. **Repository Queries**:
   - Update JSON path queries: `->` → `JSON_VALUE()`
   - Ensure partition elimination in WHERE clauses

3. **Connection Configuration**:
   ```yaml
   spring:
     datasource:
       url: jdbc:sqlserver://localhost:1433;databaseName=position_db
       driver-class-name: com.microsoft.sqlserver.jdbc.SQLServerDriver
   ```

## Comparison: PostgreSQL vs SQL Server Partitioning

| Aspect | PostgreSQL | SQL Server | Winner |
|--------|-----------|------------|--------|
| **Native Support** | ✅ Yes | ❌ No (workaround) | ✅ PostgreSQL |
| **Syntax Complexity** | Simple | More verbose | ✅ PostgreSQL |
| **Write Performance** | Excellent (~0.1ms) | Good (~0.2-0.5ms) | ✅ PostgreSQL |
| **Query Performance** | Excellent | Good | ✅ PostgreSQL |
| **Partition Pruning** | Automatic | Requires proper WHERE | ✅ PostgreSQL |
| **Maintenance** | Simple | More complex | ✅ PostgreSQL |
| **Deterministic Key** | ✅ Works | ✅ Works | ⚖️ Tie |

## Best Practices for SQL Server

### 1. Use PERSISTED Computed Column

Always use `PERSISTED` to store the hash value on disk:
```sql
partition_hash AS (ABS(HASHBYTES('SHA2_256', position_key)) % 16) PERSISTED
```

This ensures:
- Hash is computed once and stored
- Indexes can use the column
- Partition elimination works efficiently

### 2. Include Partition Hash in Clustered Index

```sql
CREATE CLUSTERED INDEX IX_event_store_partition 
ON event_store (partition_hash, position_key, event_ver)
ON ps_event_store_hash (partition_hash);
```

This ensures physical data organization matches partition boundaries.

### 3. Monitor Partition Distribution

```sql
-- Check partition distribution
SELECT 
    partition_number,
    COUNT(*) as row_count,
    MIN(position_key) as min_key,
    MAX(position_key) as max_key
FROM event_store
GROUP BY partition_number
ORDER BY partition_number;
```

### 4. Optimize for Partition Elimination

Always include `position_key` in WHERE clauses:
```sql
-- ✅ Good: Partition elimination works
SELECT * FROM event_store 
WHERE position_key = 'a1b2c3d4...';

-- ⚠️ Less efficient: May scan multiple partitions
SELECT * FROM event_store 
WHERE event_type = 'NEW_TRADE';
```

## Conclusion

**Yes, `position_key` can be partitioned in MS SQL Server**, but it requires:

1. ✅ **Computed column** with hash function
2. ✅ **Range partitioning** on the computed column
3. ✅ **Proper index alignment** with partition scheme
4. ✅ **Deterministic position_key** (which `PositionKeyGenerator` provides)

The deterministic `position_key` generated by `PositionKeyGenerator` works perfectly with SQL Server partitioning. The main differences are:

- **PostgreSQL**: Native hash partitioning (simpler, faster)
- **SQL Server**: Computed column + range partitioning (more complex, slightly slower)

Both achieve the same goal: **even distribution of data across 16 partitions based on position_key**.

## Recommendation

If you're starting fresh: **Use PostgreSQL** for native hash partitioning.

If you must use SQL Server: **The workaround works well** and the deterministic `position_key` ensures consistent partitioning. The performance difference is minimal for most workloads.
