spring:
  application:
    name: position-management-service
  
  # Database Configuration
  # Database type: postgresql or sqlserver
  # Set DB_TYPE=sqlserver to use MS SQL Server, or DB_TYPE=postgresql for PostgreSQL (default)
  # Note: Database type is configured via app.database.type, not spring.datasource.type
  datasource:
    url: ${DB_URL:}  # Optional: full JDBC URL. If not provided, constructed from DB_HOST, DB_PORT, DB_NAME
    username: ${DB_USERNAME:postgres}
    password: ${DB_PASSWORD:postgres}
    driver-class-name: ${DB_DRIVER:}  # Optional: auto-detected based on DB_TYPE
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
      pool-name: HotpathPool
  
  # JPA Configuration
  # Dialect is auto-configured based on DB_TYPE
  jpa:
    database-platform: ${JPA_DIALECT:}  # Optional: auto-detected based on DB_TYPE
    hibernate:
      ddl-auto: validate
    show-sql: false
    properties:
      hibernate:
        format_sql: true
        jdbc:
          batch_size: 50
        order_inserts: true
        order_updates: true
  
  # Flyway Configuration
  # Migration locations are auto-configured based on DB_TYPE
  flyway:
    enabled: true
    locations: ${FLYWAY_LOCATIONS:}  # Optional: auto-configured based on DB_TYPE
    baseline-on-migrate: true
    validate-on-migrate: true
  
  # Redis Configuration
  data:
    redis:
      host: ${REDIS_HOST:localhost}
      port: ${REDIS_PORT:6379}
      password: ${REDIS_PASSWORD:}
      timeout: 2000ms
      lettuce:
        pool:
          max-active: 20
          max-idle: 10
          min-idle: 5
  
  # Server Configuration
server:
  port: ${SERVER_PORT:8080}
  
  # Kafka Configuration
  kafka:
    bootstrap-servers: ${KAFKA_BOOTSTRAP_SERVERS:${KAFKA_HOST:localhost}:${KAFKA_PORT:9092}}
    consumer:
      group-id: position-service-group
      auto-offset-reset: earliest
      enable-auto-commit: false
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      properties:
        spring.json.trusted.packages: "*"
        max.poll.records: 100
        max.poll.interval.ms: 300000
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.apache.kafka.common.serialization.StringSerializer
      acks: all
      enable-idempotence: true
      retries: 3
      max-in-flight-requests-per-connection: 5
      properties:
        delivery.timeout.ms: 120000
        request.timeout.ms: 30000
    admin:
      properties:
        bootstrap.servers: ${KAFKA_BOOTSTRAP_SERVERS:localhost:9092}

# Schema Registry Configuration
schema:
  registry:
    url: ${SCHEMA_REGISTRY_URL:http://localhost:8081}
    basic-auth:
      user-info: ${SCHEMA_REGISTRY_USER:}
      source: static

# Resilience4j Configuration
resilience4j:
  circuitbreaker:
    instances:
      contractService:
        registerHealthIndicator: true
        slidingWindowSize: 10
        minimumNumberOfCalls: 5
        permittedNumberOfCallsInHalfOpenState: 3
        automaticTransitionFromOpenToHalfOpenEnabled: true
        waitDurationInOpenState: 60s
        failureRateThreshold: 50
        eventConsumerBufferSize: 10
      eventStore:
        registerHealthIndicator: true
        slidingWindowSize: 10
        minimumNumberOfCalls: 5
        waitDurationInOpenState: 30s
        failureRateThreshold: 50
  retry:
    instances:
      contractGeneration:
        maxAttempts: 3
        waitDuration: 50ms
        exponentialBackoffMultiplier: 2
        retryExceptions:
          - java.net.SocketTimeoutException
          - org.springframework.web.client.ResourceAccessException
      eventStore:
        maxAttempts: 2
        waitDuration: 100ms
        exponentialBackoffMultiplier: 2
  timelimiter:
    instances:
      contractGeneration:
        timeoutDuration: 40ms
        cancelRunningFuture: true
      eventStore:
        timeoutDuration: 50ms
  ratelimiter:
    instances:
      tradeProcessing:
        limitForPeriod: 1000
        limitRefreshPeriod: 1s
        timeoutDuration: 100ms

  # Application Configuration
app:
  # Database Configuration
  database:
    type: ${DB_TYPE:postgresql}  # postgresql or sqlserver
  
  # Contract Service Configuration
  contract:
    service:
      type: ${CONTRACT_SERVICE_TYPE:mock}  # "rest" for real service, "mock" for testing
      url: ${CONTRACT_SERVICE_URL:http://localhost:8082/api/contracts}
      enabled: ${CONTRACT_SERVICE_ENABLED:true}
    cache:
      enabled: ${CONTRACT_CACHE_ENABLED:true}  # Enable caching of contract rules
  
  # Messaging Configuration
  messaging:
    # Type: kafka, solace, rabbitmq, etc.
    # Default: kafka
    type: ${MESSAGING_TYPE:kafka}
    # Enable/disable specific implementations
    kafka:
      enabled: ${MESSAGING_KAFKA_ENABLED:true}
    solace:
      enabled: ${MESSAGING_SOLACE_ENABLED:false}
  
  # Cache Configuration
  cache:
    # Type: redis, memory, hazelcast, etc.
    # Default: redis
    type: ${CACHE_TYPE:redis}
    # Enable/disable specific implementations
    redis:
      enabled: ${CACHE_REDIS_ENABLED:true}
    memory:
      enabled: ${CACHE_MEMORY_ENABLED:false}
    # Cache configuration
    default-ttl: ${CACHE_DEFAULT_TTL:PT24H}  # Default TTL for cached entries (24 hours)
    max-size: ${CACHE_MAX_SIZE:10000}     # Max entries for in-memory cache
  
  # Partitioning
  partitioning:
    partition-count: 16
    hash-modulus: 16
  
  # Performance Targets
  performance:
    hotpath:
      target-latency-p99: 100ms
      backdated-routing-overhead: 5ms
    coldpath:
      max-recalculation-time: 5m
  
  # Backpressure Thresholds
  backpressure:
    hotpath:
      consumer-lag-alert: 1000
      consumer-lag-critical: 5000
      queue-depth-alert: 1000
      queue-depth-reject: 5000
    coldpath:
      consumer-lag-alert: 5000
      consumer-lag-critical: 10000
      queue-depth-alert: 5000
      queue-depth-scale: 10000
  
  # Validation
  validation:
    enabled: true
    dlq-topic: trade-events-dlq
    error-topic: trade-events-errors
    max-retries: 3
  
  # Idempotency
  idempotency:
    enabled: true
    retention-days: 90
  
  # Reconciliation
  reconciliation:
    enabled: true
    schedule: "0 0 * * * ?" # Hourly
    tolerance:
      quantity: 0.01
      price: 0.01

# Logging Configuration
logging:
  level:
    root: INFO
    com.bank.esps: DEBUG
    com.bank.esps.application.service: DEBUG
    com.bank.esps.application.validation: DEBUG
    org.springframework.kafka: INFO
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
  file:
    name: logs/position-service.log

# Management/Actuator Configuration
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  endpoint:
    health:
      show-details: always
  metrics:
    export:
      prometheus:
        enabled: true
    tags:
      application: ${spring.application.name}
      environment: ${ENVIRONMENT:local}

# OpenTelemetry Configuration
otel:
  service:
    name: position-management-service
  exporter:
    otlp:
      endpoint: ${OTEL_EXPORTER_OTLP_ENDPOINT:http://localhost:4317}
  traces:
    exporter: otlp
  metrics:
    exporter: prometheus
